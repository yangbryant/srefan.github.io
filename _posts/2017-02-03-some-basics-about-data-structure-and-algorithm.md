---
layout: post
title: 关于数据结构与算法的基础知识
date: 2017-02-03 09:02:00 +08:00
tags: 温故而知新
---

***

### 一. 树

#### 二叉树

* 有限个节点的集合,由一个 **根节点** 和 **两条互不相关的二叉树** 组成.

```C
typedef struct BinaryTreeNode
{
    int m_nValue;
    BinaryTreeNode* m_pLeft;
    BinaryTreeNode* m_pRight;
    
} BinaryTreeNode;
```

* 二叉树的性质:
1. 二叉树中第 **i** 层节点数 **最多** 为 **2^(i-1)**.
2. 深度为 **k** 的二叉树节点总数 **最多** 为 **2^k-1**.
3. 具有 **n** 个节点的完全二叉树的深度为 **log2(n) +1**.

* 完全二叉树和满二叉树如下:

![完全二叉树和满二叉树][FullBT_CompleteBT]

* 二叉树的遍历:前序遍历,中序遍历,后序遍历.
1. 前序遍历: 根节点->左子树->右子树.
2. 中序遍历: 左子树->根节点->右子树.
3. 后序遍历: 右子树->左子树->根节点.
4. 层次遍历: 按层次从上往下,从左向右输出.
* 仅有前序遍历和后序遍历,不能确定一个二叉树,必须有中序遍历才能确定.

![二叉树遍历的实例][tree_Traversal]

```plain
前序遍历的结果: a b de fg c
中序遍历的结果: de b gf a c
后序遍历的结果: ed gf b c a
层次遍历的结果: a bc df eg
```
 
#### 堆

* 最大堆: 完全二叉树的 **任意一个非终端节点的元素** 都 **不小于** 其 **左儿子节点** 和 **右儿子节点** (如果存在) 的元素, 则称此 **完全二叉树为最大堆**.
* 最小堆: 完全二叉树的 **任意一个非终端节点的元素** 都 **不大于** 其 **左儿子节点** 和 **右儿子节点** (如果存在) 的元素, 则称此 **完全二叉树为最小堆**.
* 最大堆的 **根节点** 的元素是整个堆中 **最大的**.
* 最小堆的 **根节点** 的元素是整个堆中 **最小的**.

#### 哈弗曼树

* Huffman Tree,又称 **最优树**.
* 给定n个权值作为n个叶子节点,构造一个二叉树,带权路径长度最小为最优二叉树,即哈弗曼树.

![哈弗曼树实例][huffman_tree]

```plain
图a: 带权路径长度: WPL = 5*2 + 7*2 + 2*2 + 13*2 = 54
图b: 带权路径长度: WPL = 5*3 + 2*3 + 7*2 + 13*1 = 48 -- 此为哈弗曼树
```

* 如何构建哈弗曼树:

![哈弗曼树的计算][huffman_tree_calc]

1. 把所有的左右子树为空的作为根节点,组成森林.
2. 从森林中选出两棵根节点权值最小的树作为一棵新树的左右子树,置新树的附加根节点权值为其左,右子树上根节点权值之和.**左子树的权值应小于右子树的权值**.
3. 从森林里删除这两棵树,新树加入到森林中.
4. 重复2,3步骤,直到森林中只有一棵树为止,此树便是哈弗曼树.

#### 二叉排序树

* 二叉排序树, Binary Sort Tree, 又称 **二叉查找树**, Binary Search Tree.
* 二叉排序树或者是一棵空树,或者是具有如下性质的二叉树:
1. 若左子树不空,则左子树上所有节点的值均 **小于** 根节点的值.
2. 若右子树不空,则右子树上所有节点的值均 **大于或者等于** 根节点的值.
3. 左右子树也分别为二叉排序树.
4. **没有键值相等** 的节点.
* 二分查找的时间复杂度为O(log(n)),最坏情况下时间复杂度为O(n).
* 缺点:树的结构是无法预料的,随意性很大,它只与节点的值和插入的顺序有关系,往往得到的是一个不平衡的二叉树.在最坏的情况下,可能得到的是一个单支二叉树,其高度和节点数相同,相当于一个单链表,对其正常的时间复杂度有O(log(n))变成了O(n),从而丧失了二叉排序树的一些应该有的优点.

#### 平衡二叉树

* 平衡二叉树, Balanced Binary Tree, 又称 AVL树.
* 平衡二叉树或者是一棵空树,或者是具有如下性质的二叉树:
1. 左右子树也分别是平衡二叉树.
2. 左右子树的 **深度之差** 绝对值不超过1.
* 平衡二叉树是对 **二叉排序树** 的改进.

#### B-树

* 是一种非二叉的查找树.除了满足树的特性,还要满足如下:
1. 一棵 m 阶的B-树, 树的根或者是一片叶子(一个节点的树),或者其儿子数在 2 和 m 之间.
2. 一棵 m 阶的B-树, 除根外,所有的非叶子结点的孩子数在 m/2 和 m 之间.
3. 一棵 m 阶的B-树, 所有的叶子结点都在相同的深度.
* B-树的平均深度为logm/2(N). 执行查找的平均时间为O(logm).

#### Trie 树

* Trie 树,又称前缀树,字典树,是一种有序树,用于保存关联数组,其中的键通常是字符串.
* 与二叉查找树不同,键不是直接保存在节点中,而是由节点在树中的位置决定.一个节点的所有子孙都有相同的前缀,也就是这个节点对应的字符串,而根节点对应空字符串.一般情况下,不是所有的节点都有对应的值,只有叶子节点和部分内部节点所对应的键才有相关的值.
* Trie 树查询和插入时间复杂度都是 O(n),是一种以空间换时间的方法.当节点树较多的时候,Trie 树占用的内存会很大.
* Trie 树常用于搜索提示.如当输入一个网址,可以自动搜索出可能的选择.当没有完全匹配的搜索结果,可以返回前缀最相似的可能.

***

### 二. TCP 协议

* TCP 提供一种 **面向连接** 的, **可靠** 的 **字节流** 服务.
* TCP 连接中, 仅有两方进行通信. **广播,多播** 不能用于TCP.
* TCP 使用 **校验和**, **确认和重传** 机制保证可靠传输.
* TCP 使用 **累计确认**.
* TCP 使用 **滑动窗口** 机制来实现流量控制, 通过 **动态改变窗口大小** 进行拥塞控制

#### 三次握手

* 三次握手, Three-way Handshake, 建立TCP连接,需要客户端和服务器发送 **三个包**.
* 三次握手的目的.连接指定端口,建立TCP连接,同步连接双方的序列号和确认号, 交换TCP窗口的大小信息.
* 在 **Socket编程** 中,客户端执行 `connect()` 时,触发三次握手.

```
第一次握手 (SYN=1, seq=x):

	客户端发送一个TCP的包, SYN 标志位 为1. 设置服务器端口,初始序号 x, 保存在包头的序列号(Sequence Number)字段.
	发送完毕后, 客户端进入 `SYN_SEND` 状态.
	
第二次握手 (SYN=1, ACK=1, seq=y, ACKnum=x+1):

	服务器发回确认包(ACK)应答, SYN标志位 和 ACK标志位 均为1. 服务器端选择自己的 ISN 序列号, 放到 Seq域里.
	同时,将确认序号(Acknowledgement Number)设置为客户的 ISN 加 1 (x+1).
	发送完毕后,服务器端进入 `SYN_RCVD` 状态.
	
第三次握手 (ACK=1, ACKnum=y+1):

	客户端再次发送确认包(ACK), SYN 标志位 为0, ACK 标志位 为1. 把服务器发来的 ACK 的序号字段 加 1 (y+1).
	放在确定字段中发送给对方, 在数据段放写 ISN+1.
	发送完毕后,客户端进入 `ESTABLISHED` 状态.
	当服务器端接收到这个包时,也进入 `ESTABLISHED` 状态, TCP握手结束.
	
```

* 三次握手过程示意图:
![三次握手过程示意图][three_way_handshake]

#### 四次挥手

* 四次挥手, Four-way Handshake, 也叫改进的三次握手. 拆除TCP连接,需要发送 **四个包**.
* 客户端或者服务器都可主动发起挥手动作.
* 在 **Socket编程** 中,任何一方执行 `close()` 时,触发挥手操作.

```
第一次挥手 (FIN=1, seq=x):

	客户端关闭连接, 发送一个 FIN 标志位 为1 的包,表示没有数据要发送了,但可以接收数据.
	发送完毕后,客户端进入 `FIN_WAIT_1` 状态.	

第二次挥手 (ACK=1, ACKnum=x+1):

	服务器端确认客户端的 FIN 包,发送一个确认包, 表明接收了关闭连接的请求,但还没准备好关闭连接.
	发送完毕后,服务器进入 `CLOSE_WAIT` 状态.
	客户端接收到这个确认包, 进入 `FIN_WAIT_2` 等待服务器关闭连接.

第三次挥手 (FIN=1, seq=y):

	服务器准备好关闭连接时,向客户端发送结束连接请求, FIN 标志位 为1.
	发送完毕后,服务器进入 `LAST_ACK` 状态,等待来自客户端的的最后一个ACK.

第四次挥手 (ACK=1, ACKnum=y+1):

	客户端接收到关闭请求,发送一个确认包,进入 `TIME_WAIT` 状态,等待可能出现的要求重传的ACK包.
	服务器接收到确认包,关闭连接,进入 `CLOSED` 状态.
	客户端等待了某个固定的时间 (2*最大段生命周期, 2*MSL, 2 Maximum Segment Lifetime) 之后,
	没有收到服务器的ACK,认为服务器已正常关闭,自己也关闭连接,进入 `CLOSED` 状态.

```

* 四次挥手过程示意图:
![四次挥手过程示意图][four_way_handshake]

#### SYN攻击

* SYN 攻击 (SYN Flood)
1. 服务器发送 **SYN-ACK** 后,收到客户端发送的 **ACK** 之前的TCP连接称为 **半连接** (half-open connect).
2. 攻击客户端在短时间内伪造大量的不存在的IP地址,向服务器发送SYN包,服务器回复确认包,等待客户端的确认.
3. 由于源客户端 **不存在** ,服务器需要 **不断重发直至超时** .
4. 这些伪造的SYN包长时间占用 **未连接队列** ,正常的SYN请求被 **丢弃** ,导致目标系统运行缓慢,网络拥堵,甚至系统瘫痪.
5. SYN攻击是一种典型的 **DoS/DDoS攻击**.

* 如何检测SYN攻击: 在服务器上看到有大量的半连接状态时,特别IP地址是随机的,基本断定是一次SYN攻击. **netstats** 命令可以检测SYN攻击.
* 如何防御SYN攻击: 在TCP协议上分析,SYN攻击不能完全被阻止.只能尽可能减轻SYN攻击的危害.常用的防御方法:
1. 缩短超时(SYN Timeout)时间
2. 增加最大半连接数
3. 过滤网关防护
4. SYN Cookies技术

***

### 三. IP 协议

#### 	IP地址分类

* IP地址 = 网络ID + 主机ID.
* 最初设计互联网络,为了便于寻址和层次化构造网络,每个IP地址包含2个标识码(网络ID和主机ID),同一个物理网络上所有主机使用同一个网络ID,网络上一个主机有一个主机ID.
* ID地址根据网络ID不同,分为 A, B, C, D, E 5类地址.

| 地址类别 | 地址范围 | 默认网络掩码 | 网络ID最高位 | 网络ID | 主机ID | 用途 | 私有地址 | 保留地址 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| A类地址 | 1.0.0.1~126.255.255.254 | 255.0.0.0 | 0 | 1Byte | 3Byte | 政府机关 | 10.0.0.0~10.255.255.255 | 127.x.x.x |
| B类地址 | 128.0.0.1~191.255.255.254 | 255.255.0.0 | 10 | 2Byte | 2Byte | 大中型企业 | 172.16.0.0~172.31.255.255 | 169.254.x.x |
| C类地址 | 192.0.0.1~223.255.255.254 | 255.255.255.0 | 110 | 3Byte | 1Byte | 个人 | 192.168.0.0~192.168.255.255 | |
| D类地址 | 224.0.0.1~239.255.255.254 | | 1110 | | | 组播 | | |
| E类地址 | 240.0.0.1~255.255.255.254 | | 11110 | | | 保留 | | |

* 私有地址是指在互联网中不使用,而被用在局域网络中的地址.
* 127.x.x.x是A类地址的保留地址,用作 **循环测试**.
* 169.254.x.x是B类地址的保留地址,用作 **自动获取IP,却找不到DHCP服务器** 时, 分配其中IP.
* 240.0.0.0 ~ 255.255.255.254是E类地址的保留地址,用作 **Internet试验和开发**.
* 255.255.255.255是广播地址, 0.0.0.0是当前主机地址.

#### 广播与多播

* 广播与多播仅用于 **UDP**. (TCP是面向连接的).

* 广播有4种广播地址:
1. **受限的广播**: 地址为 **255.255.255.255**,用于主机配置过程中IP数据报的目的地址,路由不转发目的地址为255.255.255.255的数据报,仅在本地网络中使用.
2. **指向网络的广播**: 地址为 **主机ID全为1** 的地址. 例如: A类网络广播地址: NetID.255.255.255,(NetID为A类网络的网络号). 一个路由必须转发指向网络的广播,但也必须有一个不进行转发的选择.
3. **指向子网的广播**: 地址为 **主机ID全为1且有特定子网号** 的地址.作为子网直接广播地址的IP地址需要了解子网的掩码. 例如: 路由收到128.1.2.255的数据报,若B类网络128.1的掩码为255.255.255.0,该地址就是指向子网的广播地址,但如果掩码为255.255.254.0,该地址就不是指向子网的广播地址.
4. **指向所有子网的广播**: 地址为 **子网号和主机号为全1** 的地址. 这种广播是陈旧过时的,更好的方式是使用多播而不是对所有子网的广播.

* 多播, 又叫 **组播**, D类地址的 **低28位** 用来多播组号.多播组地址包含高4位 **1110** 和低28位 **多播组号**.范围为 224.0.0.0 ~ 239.255.255.255.
* 多播减少了对与应用无关主机的处理负荷.
* 多播特点:
1. 允许一个或多个发送者(组播源)发送单一数据报到多个接受者.
2. 节省网络带宽.
3. 在节省网络资源的前提下保证服务质量.

#### BGP

* 边界网关协议(BGP)是运行于TCP上一种自治系统的路由协议.
* BGP是唯一一个用来处理像因特网大小的网络协议,也是唯一能够妥善处理好不相关路由域间的多路连接的协议.
* BGP是一种外部网关协议(Exterior Gateway Protocol,EGP),与OSPF,RIP等内部网关协议(Interior Gateway Protocol,IGP)不同,BGP不在于发现和计算路由,而在于控制路由的传播和选择最佳路由.
* BGP使用TCP作为其传输层协议(端口号179),提高了协议的可靠性.
* BGP既不是纯粹的矢量距离协议,也不是纯粹的链路状态协议.
* BGP支持CIDR(Classless Inter-Domain Routing,无类别域间路由).
* 路由更新时,BGP只发送更新的路由,大大减少了BGP传播路由所占用的带宽,适用于在Internet上传播大量的路由信息.
* BGP路由通过携带AS路径信息彻底解决路由环路问题.
* BGP提供了丰富的路由策略,能够对路由实现灵活的过滤和选择.
* BGP易于扩展,能够适应网络新的发展.

***

### 四. Socket 编程

* Socket是对 **TCP/IP协议簇** 的一种封装,是应用层与TCP/IP协议簇通信的 **中间软件抽象层**.

#### 简易的 WebServer 实例

* 流程如下:
1. 建立连接: 接受一个客户端连接.
2. 接受请求: 从网络中读取一条 HTTP 请求报文.
3. 处理请求: 访问资源.
4. 构建响应: 创建带有 **Header** 的 HTTP 响应报文.
5. 发送响应: 传给客户端.

* 函数逻辑如下:
1. socket(): 创建套接字.
2. bind(): 分配套接字地址.
3. listen(): 等待连接请求.
4. accept(): 允许连接请求.
5. read()/write(): 数据交换.
6. close(): 关闭连接.


***

此文参考于 [hit-alibaba.github.io][hit-alibaba.github.io],十分感谢.  
所有引用内容版权归原作者所有.  
使用 [知识共享“署名-非商业性使用-相同方式共享 3.0 中国大陆”许可协议][Lisence] 授权.

[Get_Post_Diff]: http://www.cnblogs.com/hyddd/archive/2009/03/31/1426026.html
[Content_Length]: http://www.cnblogs.com/skynet/archive/2010/12/11/1903347.html
[hit-alibaba.github.io]: https://hit-alibaba.github.io/interview/
[Lisence]: https://creativecommons.org/licenses/by-nc-sa/3.0/cn/

[FullBT_CompleteBT]: /assets/images/data_structure/FullBT_CompleteBT.jpg 'FullBT_CompleteBT'
[tree_Traversal]: /assets/images/data_structure/tree_Traversal.jpg 'tree_Traversal'
[huffman_tree]: /assets/images/data_structure/huffman_tree.jpg 'huffman_tree'
[huffman_tree_calc]: /assets/images/data_structure/huffman_tree_calc.jpg 'huffman_tree_calc'